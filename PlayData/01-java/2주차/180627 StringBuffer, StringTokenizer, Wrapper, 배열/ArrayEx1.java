/*
배열 Array
	같은 자료형의 모임
	index는 0부터 시작
연속적인 메모리 할당
	자바에서는 배열도 객체다
*/

class ArrayEx1 {
	public static void main(String[] args) {
	//	int m[3];				// C에선 이게 무조건 됩니다. int 방 3개 잡아라. stack 에 잡으란 소리
	//	int m[] = new int[3];	// int 형m(참조변수)이라는 방에 new/*heap에 만들어라*/ int 방 3개를 잡아라
	//	int [] m = new int[3];	// 이렇게 배열의 참조변수를 뒤에 써도 된다. main( String args[] ) / 명령줄 인수를 받아주는 배열 / 이렇게도 된다는 소리 
	
	//	int [] m = new int[3] {10, 20, 30};		// 에러 /데이터 한번에 많이 넣을 땐 항상 {} 중괄호 쓴다. 다른언어 다 같음 /  배열방 3개만들면서 초기값주는건데, C에서는 3이라는 값을 생략해도 되고 안해도 되는데 / 자바는 이럴 땐 항상 생략을 해야해
	//	int [] m = new int[] {10, 20, 30};		// 이렇게 하면 비로소 배열 잡으면서 초기값을 잡는다.

	// 이렇게 하면 너무 불편하니까 하나 되게 한게
		int [] m = { 10, 20, 30 };	// 이게 됩니다 / 이렇게 해도 new 된거 맞습니다 / 단 이렇게 할 수 있는건 초기값을 줄 때만. / 값이 없는 빈 배열을 만들 때는 무조건 new 써서 만들어야 함
		
		System.out.println("m[0] : " + m[0]);
		System.out.println("m[1] : " + m[1]);
		System.out.println("m[2] : " + m[2]);
			
		m[1] = 40;	// 얘네가 이렇게 변수 역할도 할 수 있다는 것을 알아두세여
		m[2] = 50;

			for(int i=0 ; i< m.length ; i++){		//length 는 변수다 / 필드도 아니고 변수인데 그냥 이렇게 쓰나?
				System.out.println("m["+i+"] : " + m[i] );
			}

			// 개선된 루프 for ~ each문 / for ~ in 문		/ 단점 : 얘는 i 가 없어서 인덱스를 못써 / 인덱스를 못 쓰니까 중간중간 방을 골라서 작업하는게 안됨. / 그래서 출력할 때 정도만 쓸거야.
			//	a라는 배열에	/첫번째 값 -> 사용 ->올라가서 반복	/ 또 단점 : m 자리에는 배열이나 컬렉션만 들아가는게 가능 / 변수는 같은 자료형의 변수만 / 다른 언어에서는 좀 달라
			for( int a : m ) {			// 1.5부터 나옴 / 다른 언어로 넘어가면 for~each 혹은 for ~in 방법문(이렇게 많이 씀)이라고 한다  
				System.out.println( a );
			}	// 다른 언어에서는 a라는 배열에 / 첫번째 인덱스 / 요렇게 쓰이기도 해서 유용할 수 있어
	}
}
/*
원래 배열의 진도는 (난이도상)
다중 for문 뒤에 배웠어야 하는데
여기서 배우는 이유는, 자바에서의 배열이 C에서의 배열과 다르기 때문이다.

C에서는 객체를 스택과 힙 중 저장공간 선택이 가능해
우리는 자동으로 관리해야 하는 편리함을 얻기 위해, 무조건 힙에만 잡아야 한다고 했어
우리가 하는 메모리관리는, 힙 영역에 올리는 것만 해주면 된다 그랬어.

우리가 왜 힙에다 안 썼는데 클래스부터 (객체생성부터) 힙에다 저장을 하냐면, 메모리가 커서 그래
배열도 메모리가 커. '배열은 같은 자료형의 모임'. 당연히 관리가 필요해
	우리한테 관리란 힙에다 올리는게 관리
	그래서 우리는 stack 에 배열을 올리는게 불가능해(new 해서 잡아야한다는(할당받아야 한다는) 얘기)
	그래서 자바에서는 배열도 객체다.


엄밀히 말하면 배열은 포인터라 되게 어려운데 자바는 별로 안쓰니깡 ㅇㅇ
*/